##
# The Creative Commons CC-BY-NC 4.0 License
#
# http://creativecommons.org/licenses/by-nc/4.0/legalcode
#
# Creative Commons (CC) by DFKI GmbH
#  - Christian Buerckert <Christian.Buerckert@DFKI.de>
#  - Yannick Koerber <Yannick.Koerber@DFKI.de>
#  - Magdalena Kaiser <Magdalena.Kaiser@DFKI.de>

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
# IN THE SOFTWARE.
#
#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ProgrammingLanguage:
  SHEEP = 0
  CPP = 1
  CSHARP = 2
  JAVA = 3
  PYTHON = 4
  RUBY = 5

  _VALUES_TO_NAMES = {
    0: "SHEEP",
    1: "CPP",
    2: "CSHARP",
    3: "JAVA",
    4: "PYTHON",
    5: "RUBY",
  }

  _NAMES_TO_VALUES = {
    "SHEEP": 0,
    "CPP": 1,
    "CSHARP": 2,
    "JAVA": 3,
    "PYTHON": 4,
    "RUBY": 5,
  }


class Login:
  """
  Used to login into the server.

  Attributes:
   - id: The id of the client
   - password: Password will be used in the future to authenticate the client.
  Currently it is ignored.
   - subscribes: Name of the events you want to receive. If this field is not set, you will receive all
  events.Events described here (PingEvent & PongEvent) are sent by the server event withouth
  subscribing.
   - language: Defines the name of the programming language connecting
  This can be eighter, 'Sheep', 'C++', 'C#', 'Java', 'Python', 'Ruby'
  If unknown use 'Sheep'
   - languageVersion: If available the client library will attach the programming language's version
   - operatingSystem: If accessable the client will put a string describing the operating system here
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.SET, 'subscribes', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'language', None,     0, ), # 6
    (7, TType.STRING, 'languageVersion', None, None, ), # 7
    (8, TType.STRING, 'operatingSystem', None, None, ), # 8
  )

  def __init__(self, id=None, password=None, subscribes=None, language=thrift_spec[6][4], languageVersion=None, operatingSystem=None,):
    self.id = id
    self.password = password
    self.subscribes = subscribes
    self.language = language
    self.languageVersion = languageVersion
    self.operatingSystem = operatingSystem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.subscribes = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString()
            self.subscribes.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.language = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.languageVersion = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.operatingSystem = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Login')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.subscribes is not None:
      oprot.writeFieldBegin('subscribes', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.subscribes))
      for iter6 in self.subscribes:
        oprot.writeString(iter6)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.language is not None:
      oprot.writeFieldBegin('language', TType.I32, 6)
      oprot.writeI32(self.language)
      oprot.writeFieldEnd()
    if self.languageVersion is not None:
      oprot.writeFieldBegin('languageVersion', TType.STRING, 7)
      oprot.writeString(self.languageVersion)
      oprot.writeFieldEnd()
    if self.operatingSystem is not None:
      oprot.writeFieldBegin('operatingSystem', TType.STRING, 8)
      oprot.writeString(self.operatingSystem)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.password is None:
      raise TProtocol.TProtocolException(message='Required field password is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.subscribes)
    value = (value * 31) ^ hash(self.language)
    value = (value * 31) ^ hash(self.languageVersion)
    value = (value * 31) ^ hash(self.operatingSystem)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventHeader:
  """
  Will be sent as a header for all events

  Attributes:
   - target: Regular Expression describing the targets which should receive this event
   - source: Source id of the client who has sent this event
  If missing the server will attach it.
   - time: Time in milliseconds since the unix epoch (time of the source's computer)
  If missing the server will attach it with its current time
   - etype: The name of the event. i.e. "PingEvent"
  If missing the server will attach it
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'target', None, ".*", ), # 1
    (2, TType.STRING, 'source', None, None, ), # 2
    (3, TType.I64, 'time', None, None, ), # 3
    (4, TType.STRING, 'etype', None, None, ), # 4
  )

  def __init__(self, target=thrift_spec[1][4], source=None, time=None, etype=None,):
    self.target = target
    self.source = source
    self.time = time
    self.etype = etype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.target = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.etype = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventHeader')
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRING, 1)
      oprot.writeString(self.target)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 2)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.I64, 3)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    if self.etype is not None:
      oprot.writeFieldBegin('etype', TType.STRING, 4)
      oprot.writeString(self.etype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.etype is None:
      raise TProtocol.TProtocolException(message='Required field etype is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.target)
    value = (value * 31) ^ hash(self.source)
    value = (value * 31) ^ hash(self.time)
    value = (value * 31) ^ hash(self.etype)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SheepEvent:
  """
  Sheep Events will be acceptable by any client. After receiving it will put
  the string in wool on the std output.

  Attributes:
   - wool: What you want to sheep.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'wool', None, None, ), # 1
  )

  def __init__(self, wool=None,):
    self.wool = wool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.wool = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SheepEvent')
    if self.wool is not None:
      oprot.writeFieldBegin('wool', TType.STRING, 1)
      oprot.writeString(self.wool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.wool is None:
      raise TProtocol.TProtocolException(message='Required field wool is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.wool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PingEvent:
  """
  PingEvent Clients will automatically respond with a PongEvent if this event is processed.

  Attributes:
   - requestTime: Time of the client who requests the ping
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'requestTime', None, None, ), # 1
  )

  def __init__(self, requestTime=None,):
    self.requestTime = requestTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.requestTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PingEvent')
    if self.requestTime is not None:
      oprot.writeFieldBegin('requestTime', TType.I64, 1)
      oprot.writeI64(self.requestTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.requestTime is None:
      raise TProtocol.TProtocolException(message='Required field requestTime is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PongEvent:
  """
  Pong Event is needed to reply to Ping Events

  Attributes:
   - requestTime: time of the request copied from the client.
   - responseTime: time of the response
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'requestTime', None, None, ), # 1
    (2, TType.I64, 'responseTime', None, None, ), # 2
  )

  def __init__(self, requestTime=None, responseTime=None,):
    self.requestTime = requestTime
    self.responseTime = responseTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.requestTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.responseTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PongEvent')
    if self.requestTime is not None:
      oprot.writeFieldBegin('requestTime', TType.I64, 1)
      oprot.writeI64(self.requestTime)
      oprot.writeFieldEnd()
    if self.responseTime is not None:
      oprot.writeFieldBegin('responseTime', TType.I64, 2)
      oprot.writeI64(self.responseTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.requestTime is None:
      raise TProtocol.TProtocolException(message='Required field requestTime is unset!')
    if self.responseTime is None:
      raise TProtocol.TProtocolException(message='Required field responseTime is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestTime)
    value = (value * 31) ^ hash(self.responseTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ServiceRequest:
  """
  Requests a service based on type and id.

  Attributes:
   - requestId: This value is copied into a response (see ServiceResponse::responseId) and
  allows to identify request-response pairs.
   - serviceType: Regex used for filtering: Each receiver decides based on this regex whether its
  services match.
  E.g. madmacs\\.dfki\\.de/services/.*
  See Service::type .

   - port: The response will be sent via unicast if the port is set.
   - serviceId: Additional filtering: Only services with this id will be sent.
  See Service::id .
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requestId', None, "", ), # 1
    (2, TType.STRING, 'serviceType', None, None, ), # 2
    (3, TType.I32, 'port', None, None, ), # 3
    (4, TType.STRING, 'serviceId', None, None, ), # 4
  )

  def __init__(self, requestId=thrift_spec[1][4], serviceType=None, port=None, serviceId=None,):
    self.requestId = requestId
    self.serviceType = serviceType
    self.port = port
    self.serviceId = serviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requestId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serviceType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.serviceId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServiceRequest')
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 1)
      oprot.writeString(self.requestId)
      oprot.writeFieldEnd()
    if self.serviceType is not None:
      oprot.writeFieldBegin('serviceType', TType.STRING, 2)
      oprot.writeString(self.serviceType)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 3)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.serviceId is not None:
      oprot.writeFieldBegin('serviceId', TType.STRING, 4)
      oprot.writeString(self.serviceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.requestId is None:
      raise TProtocol.TProtocolException(message='Required field requestId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.serviceType)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.serviceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Service:
  """
  A service that runs in an IP network.

  Attributes:
   - id: Unique identifier for this instance. e.g. a UUID
  It is used to merge same services on different networks
   - type: Unique identifier for the type of the service.
  e.g. your.domain.com/services/YourService,
       MyAudioService or
       CookieService
   - URIs: URIs describing the resource in a user space defined way.
  tecs uses,
    - tecs-ps://[host]:[port]
    - tecs-mp://[host]:[port]
    - tecs-rpc://[host]:[port]/([Multiplexer])
    - tecs-rpc-http://[host]:[port]/([Multiplexer])
  If you use URI_HOST inside a string it will be replaced with the correct network host.
   - data1: Placeholder #1 to encode additional information.
   - data2: Placeholder #2 to encode additional information.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.LIST, 'URIs', (TType.STRING,None), [
    ], ), # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'data1', None, None, ), # 10
    (11, TType.STRING, 'data2', None, None, ), # 11
  )

  def __init__(self, id=None, type=None, URIs=thrift_spec[5][4], data1=None, data2=None,):
    self.id = id
    self.type = type
    if URIs is self.thrift_spec[5][4]:
      URIs = [
    ]
    self.URIs = URIs
    self.data1 = data1
    self.data2 = data2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.URIs = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.URIs.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.data1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.data2 = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Service')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.URIs is not None:
      oprot.writeFieldBegin('URIs', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.URIs))
      for iter13 in self.URIs:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.data1 is not None:
      oprot.writeFieldBegin('data1', TType.STRING, 10)
      oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 is not None:
      oprot.writeFieldBegin('data2', TType.STRING, 11)
      oprot.writeString(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.URIs)
    value = (value * 31) ^ hash(self.data1)
    value = (value * 31) ^ hash(self.data2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ServiceResponse:
  """
  Answers a ServiceRequest.

  Attributes:
   - responseId: Contains the id of the request (see ServiceRequest::requestId).
   - service_: tldr: null - service not found

  The requested service. The field isn't set if the service wasn't found.
  While using multicast/broadcast services will only answer if they fulfill the request.
  However, if a service provider runs on e.g. a TCP connection, it may answer with an empty
  service if can't fulfill the request.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'responseId', None, None, ), # 1
    (2, TType.STRUCT, 'service_', (Service, Service.thrift_spec), None, ), # 2
  )

  def __init__(self, responseId=None, service_=None,):
    self.responseId = responseId
    self.service_ = service_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.responseId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.service_ = Service()
          self.service_.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServiceResponse')
    if self.responseId is not None:
      oprot.writeFieldBegin('responseId', TType.STRING, 1)
      oprot.writeString(self.responseId)
      oprot.writeFieldEnd()
    if self.service_ is not None:
      oprot.writeFieldBegin('service_', TType.STRUCT, 2)
      self.service_.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.responseId is None:
      raise TProtocol.TProtocolException(message='Required field responseId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.responseId)
    value = (value * 31) ^ hash(self.service_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IPResolveRequest:
  """
  Request to resolve the IP address of the sender.

  Attributes:
   - requestId: The corresponding response(s) contain this id. See IPResolveResponse::responseId
   - port: The answer will be sent via UDP unicast to this port using the host of the received
  UDP message.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requestId', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, requestId=None, port=None,):
    self.requestId = requestId
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requestId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IPResolveRequest')
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 1)
      oprot.writeString(self.requestId)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.requestId is None:
      raise TProtocol.TProtocolException(message='Required field requestId is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IPResolveResponse:
  """
  Contains the IP address of the sender. Multiple responses may be sent with different IPs if
  replying services are accessible through different interfaces (wifi / ethernet / localhost / ..)

  Attributes:
   - responseId: Contains the id of the corresponding request. See IPResolveRequest::requestId
   - ip: The ip of the requester.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'responseId', None, None, ), # 1
    (2, TType.STRING, 'ip', None, None, ), # 2
  )

  def __init__(self, responseId=None, ip=None,):
    self.responseId = responseId
    self.ip = ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.responseId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IPResolveResponse')
    if self.responseId is not None:
      oprot.writeFieldBegin('responseId', TType.STRING, 1)
      oprot.writeString(self.responseId)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 2)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.responseId is None:
      raise TProtocol.TProtocolException(message='Required field responseId is unset!')
    if self.ip is None:
      raise TProtocol.TProtocolException(message='Required field ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.responseId)
    value = (value * 31) ^ hash(self.ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DiscoveryMessage:
  """
  Those messages encapsulate request-response messages used
  for service discovery and ip resolution in UDP messages.

  Attributes:
   - serviceRequest
   - serviceResponse
   - ipResolveRequest
   - ipResolveResponse
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'serviceRequest', (ServiceRequest, ServiceRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'serviceResponse', (ServiceResponse, ServiceResponse.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ipResolveRequest', (IPResolveRequest, IPResolveRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ipResolveResponse', (IPResolveResponse, IPResolveResponse.thrift_spec), None, ), # 4
  )

  def __init__(self, serviceRequest=None, serviceResponse=None, ipResolveRequest=None, ipResolveResponse=None,):
    self.serviceRequest = serviceRequest
    self.serviceResponse = serviceResponse
    self.ipResolveRequest = ipResolveRequest
    self.ipResolveResponse = ipResolveResponse

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.serviceRequest = ServiceRequest()
          self.serviceRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.serviceResponse = ServiceResponse()
          self.serviceResponse.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ipResolveRequest = IPResolveRequest()
          self.ipResolveRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ipResolveResponse = IPResolveResponse()
          self.ipResolveResponse.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DiscoveryMessage')
    if self.serviceRequest is not None:
      oprot.writeFieldBegin('serviceRequest', TType.STRUCT, 1)
      self.serviceRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.serviceResponse is not None:
      oprot.writeFieldBegin('serviceResponse', TType.STRUCT, 2)
      self.serviceResponse.write(oprot)
      oprot.writeFieldEnd()
    if self.ipResolveRequest is not None:
      oprot.writeFieldBegin('ipResolveRequest', TType.STRUCT, 3)
      self.ipResolveRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.ipResolveResponse is not None:
      oprot.writeFieldBegin('ipResolveResponse', TType.STRUCT, 4)
      self.ipResolveResponse.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.serviceRequest)
    value = (value * 31) ^ hash(self.serviceResponse)
    value = (value * 31) ^ hash(self.ipResolveRequest)
    value = (value * 31) ^ hash(self.ipResolveResponse)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AppConfig:
  """
  Specifies a Application Configuration

  Attributes:
   - name: Unique Identifier
   - dir: Directory in which the application will be executed
   - cmd: The Command to be executed
   - arguments: Additional Arguments for this command
   - user: If the App should be executed under a different user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'dir', None, None, ), # 2
    (3, TType.STRING, 'cmd', None, None, ), # 3
    (4, TType.LIST, 'arguments', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'user', None, None, ), # 5
  )

  def __init__(self, name=None, dir=None, cmd=None, arguments=None, user=None,):
    self.name = name
    self.dir = dir
    self.cmd = cmd
    self.arguments = arguments
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dir = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cmd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.arguments = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString()
            self.arguments.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppConfig')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.dir is not None:
      oprot.writeFieldBegin('dir', TType.STRING, 2)
      oprot.writeString(self.dir)
      oprot.writeFieldEnd()
    if self.cmd is not None:
      oprot.writeFieldBegin('cmd', TType.STRING, 3)
      oprot.writeString(self.cmd)
      oprot.writeFieldEnd()
    if self.arguments is not None:
      oprot.writeFieldBegin('arguments', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.arguments))
      for iter20 in self.arguments:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 5)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.dir is None:
      raise TProtocol.TProtocolException(message='Required field dir is unset!')
    if self.cmd is None:
      raise TProtocol.TProtocolException(message='Required field cmd is unset!')
    if self.arguments is None:
      raise TProtocol.TProtocolException(message='Required field arguments is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.dir)
    value = (value * 31) ^ hash(self.cmd)
    value = (value * 31) ^ hash(self.arguments)
    value = (value * 31) ^ hash(self.user)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AppConfigs:
  """
  Attributes:
   - all
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'all', (TType.STRUCT,(AppConfig, AppConfig.thrift_spec)), [
    ], ), # 1
  )

  def __init__(self, all=thrift_spec[1][4],):
    if all is self.thrift_spec[1][4]:
      all = [
    ]
    self.all = all

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.all = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = AppConfig()
            _elem26.read(iprot)
            self.all.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppConfigs')
    if self.all is not None:
      oprot.writeFieldBegin('all', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.all))
      for iter27 in self.all:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.all is None:
      raise TProtocol.TProtocolException(message='Required field all is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.all)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
